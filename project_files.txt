--- app/layout.tsx ---
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import Navbar from './components/Navbar'; // Adjust the import path as necessary
import Footer from './components/Footer';
const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <head>
        <title>{String(metadata.title)}</title>
        <meta name="description" content={metadata.description ?? ''} />
      </head>
      <body className={inter.className}>
        <Navbar />
        <div className="content">
          {children}
        </div>
        <Footer />
      </body>
    </html>
  );
}


--- app/page.tsx ---
"use client";
import { useState, useEffect } from 'react';
import PlantGrid from './components/PlantGrid';
import PlantDetails from './components/PlantDetails';

interface SensorData {
  temp: number[];
  humidity: number[];
  light: number[];
  soil_moisture: number[];
  timestamps: string[];
  pump_status: string;
}

export default function Home() {
  const [selectedPlant, setSelectedPlant] = useState<number | null>(null);
  const [data, setData] = useState<SensorData | null>({
    temp: [],
    humidity: [],
    light: [],
    soil_moisture: [],
    timestamps: [],
    pump_status: 'OFF',
  });

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('/api/sensor-data');
        if (response.ok) {
          const result: SensorData = await response.json();
          setData(result);
        } else {
          console.error('Failed to fetch data:', response.statusText);
        }
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    };

    fetchData();
    const interval = setInterval(fetchData, 2000);

    return () => clearInterval(interval);
  }, []);

  const handleSelectPlant = (id: number) => {
    setSelectedPlant(id);
  };

  if (selectedPlant === 1 && data) {
    return <PlantDetails data={data} plant={{ id: 1, name: 'Plant 1', src: '/plant1.svg' }} />;
  }

  return (
    <div>
      <PlantGrid onSelect={handleSelectPlant} />
    </div>
  );
}


--- app/globals.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}



.card {
  transition: all 0.3s ease;
}

.card.expanded {
  transform: translateX(-20px);
  z-index: 10;
  grid-column: span 2;
}



--- app/components/Footer.tsx ---
File not found.

--- app/components/Navbar.tsx ---
// components/Navbar.tsx
"use client";

export default function Navbar() {
  const handleRefresh = () => {
    window.location.href = '/'; // Reload the page and navigate to the root
  };

  return (
    <div className="navbar justify-center bg-base-100">
      <button 
        className="btn btn-ghost text-center text-xl" 
        onClick={handleRefresh}
      >
        Smart Grow House Monitor
      </button>
    </div>
  );
}


--- app/components/PlantDetails.tsx ---
import { useState, useEffect } from 'react';
import Image from 'next/image';
import LineChart from './LineChart';

interface SensorData {
  temp: number[];
  humidity: number[];
  light: number[];
  soil_moisture: number[];
  timestamps: string[];
  pump_status: string;
}

interface PlantDetailsProps {
  plant: {
    id: number;
    name: string;
    src: string;
  };
  data: SensorData;
}

const calculateSoilMoisturePercentage = (value: number): number => {
  const minMoisture = 25000; // 100% moisture
  const maxMoisture = 56000; // 0% moisture

  if (value <= minMoisture) return 100; // Values lower than or equal to minMoisture are considered 100% moisture
  if (value >= maxMoisture) return 0; // Values greater than or equal to maxMoisture are considered 0% moisture

  // Linearly interpolate between minMoisture and maxMoisture to get a percentage
  return Math.round(((maxMoisture - value) / (maxMoisture - minMoisture)) * 100);
};

const calculateLightIntensityPercentage = (value: number): number => {
  const minLight = 1000; // 0% light
  const maxLight = 65000; // 100% light

  if (value <= minLight) return 0; // Values lower than or equal to minLight are considered 0% light
  if (value >= maxLight) return 100; // Values greater than or equal to maxLight are considered 100% light

  // Linearly interpolate between minLight and maxLight to get a percentage
  return Math.round(((value - minLight) / (maxLight - minLight)) * 100);
};

const checkSoilMoisture = async (soilMoisture: number, pumpStatus: string) => {
  const sendEmailNotification = async (subject: string, text: string) => {
    await fetch('/api/send-email', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        subject: subject,
        text: text,
      }),
    });
  };

  const threshold = 30; // Example threshold for soil moisture
  const notificationInterval = 300000; // 5 minute in milliseconds

  const getLastNotificationTime = (): number => {
    const lastTime = localStorage.getItem('lastNotificationTime');
    return lastTime ? parseInt(lastTime) : 0;
  };

  const setLastNotificationTime = (time: number) => {
    localStorage.setItem('lastNotificationTime', time.toString());
  };

  const currentTime = Date.now();
  const lastNotificationTime = getLastNotificationTime();

  if (soilMoisture < threshold && (currentTime - lastNotificationTime > notificationInterval)) {
    await sendEmailNotification('Soil Moisture Alert', 'The soil moisture level is low. Please water your plants.');
    setLastNotificationTime(currentTime);
  }

  if (pumpStatus === 'ON') {
    await sendEmailNotification('Pump Activated', 'The pump has been activated.');
  }
};

export default function PlantDetails({ plant, data }: PlantDetailsProps) {
  const [ledStatus, setLedStatus] = useState({ red: 0, green: 0, blue: 0 });
  const [pumpStatus, setPumpStatus] = useState(data ? data.pump_status : 'OFF');
  const [hoveredCard, setHoveredCard] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('/api/sensor-data', {
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
            'Expires': '0',
          },
        });
        if (response.ok) {
          const result: SensorData = await response.json();
          console.log('Fetched Data:', result);  // Debugging log
          setPumpStatus(result.pump_status);  // Update pump status

          // Check soil moisture and pump status to send notifications
          const latestSoilMoisture = calculateSoilMoisturePercentage(result.soil_moisture[result.soil_moisture.length - 1]);
          await checkSoilMoisture(latestSoilMoisture, result.pump_status);

        } else {
          console.error('Failed to fetch data:', response.statusText);
        }
      } catch (error) {
        console.error('Failed to fetch sensor data:', error);
      }
    };

    fetchData();
    const intervalId = setInterval(fetchData, 10000); // Fetch data every 10 seconds

    return () => clearInterval(intervalId); // Clean up the interval on component unmount
  }, []);

  const updateLedStatus = async (color: string, value: number) => {
    const newStatus = { ...ledStatus, [color]: value };
    const response = await fetch('/api/control-led', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(newStatus),
    });

    if (response.ok) {
      setLedStatus(newStatus);
      console.log('LED status updated');
    } else {
      console.error('Failed to update LED status');
    }
  };

  const togglePump = async () => {
    const newStatus = pumpStatus === 'OFF' ? 'ON' : 'OFF';
    const response = await fetch('/api/control-pump', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ status: newStatus }),
    });

    if (response.ok) {
      setPumpStatus(newStatus);
      console.log('Pump status updated');
    } else {
      console.error('Failed to update pump status');
    }
  };

  if (!data) {
    return <div>Loading...</div>;
  }

  return (
    <div className="hero min-h-screen bg-base-200 flex flex-col items-center justify-center">
      <h1 className="text-3xl font-bold mb-6">{plant.name}</h1>
      <div className="hero-content flex-col lg:flex-row items-start gap-8 p-4 max-w-4xl w-full">
        <div className="grid grid-cols-1 gap-4 w-full lg:w-1/3">
          <div
            className="card bg-red-50 shadow-md hover-expand relative"
            onMouseEnter={() => setHoveredCard('temp')}
            onMouseLeave={() => setHoveredCard(null)}
          >
            <div className="card-body items-center text-center">
              <h2 className="card-title text-lg">Temperature</h2>
              <p className="text-4xl font-bold">{data.temp.length > 0 ? data.temp[0] : 'N/A'} °C</p>
              {hoveredCard === 'temp' && (
                <div className="absolute top-0 right-full mr-4 p-4 bg-white shadow-lg rounded-lg chart-container">
                  <LineChart data={data.temp} labels={data.timestamps} />
                </div>
              )}
            </div>
          </div>
          <div
            className="card bg-blue-50 shadow-md hover-expand relative"
            onMouseEnter={() => setHoveredCard('humidity')}
            onMouseLeave={() => setHoveredCard(null)}
          >
            <div className="card-body items-center text-center">
              <h2 className="card-title text-lg">Humidity</h2>
              <p className="text-4xl font-bold">{data.humidity.length > 0 ? data.humidity[0] : 'N/A'} %</p>
              {hoveredCard === 'humidity' && (
                <div className="absolute top-0 right-full mr-4 p-4 bg-white shadow-lg rounded-lg chart-container">
                  <LineChart data={data.humidity} labels={data.timestamps} />
                </div>
              )}
            </div>
          </div>
          <div
            className="card bg-yellow-50 shadow-md hover-expand relative"
            onMouseEnter={() => setHoveredCard('light')}
            onMouseLeave={() => setHoveredCard(null)}
          >
            <div className="card-body items-center text-center">
              <h2 className="card-title text-lg">Light</h2>
              <p className="text-4xl font-bold">
                {data.light.length > 0 ? calculateLightIntensityPercentage(data.light[0]) : 'N/A'} %
              </p>
              {hoveredCard === 'light' && (
                <div className="absolute top-0 right-full mr-4 p-4 bg-white shadow-lg rounded-lg chart-container">
                  <LineChart data={data.light.map(calculateLightIntensityPercentage)} labels={data.timestamps} />
                </div>
              )}
            </div>
          </div>
          <div
            className="card bg-green-50 shadow-md hover-expand relative"
            onMouseEnter={() => setHoveredCard('soil')}
            onMouseLeave={() => setHoveredCard(null)}
          >
            <div className="card-body items-center text-center">
              <h2 className="card-title text-lg">Soil Moisture</h2>
              <p className="text-4xl font-bold">
                {data.soil_moisture.length > 0 ? calculateSoilMoisturePercentage(data.soil_moisture[0]) : 'N/A'} %
              </p>
              {hoveredCard === 'soil' && (
                <div className="absolute bottom-0 right-full mr-4 p-4 bg-white shadow-lg rounded-lg chart-container">
                  <LineChart data={data.soil_moisture.map(calculateSoilMoisturePercentage)} labels={data.timestamps} />
                </div>
              )}
            </div>
          </div>
        </div>
        <div className="text-left w-full lg:w-1/3">
          <div className="card bg-base-100 shadow-md mb-4" style={{ height: '295px' }}>
            <div className="card-body p-0">
              <div className="relative" style={{ width: '100%', height: '100%' }}>
                <Image src={plant.src} alt={plant.name} layout="fill" objectFit="cover" className="rounded-lg" />
              </div>
            </div>
          </div>
          <div className="card bg-base-100 shadow-md mb-4" style={{ height: '140px'}}>
            <div className="card-body p-4 flex flex-col justify-between">
              <h2 className="card-title">Control Grow Light</h2>
              <div className="flex flex-row space-x-4 items-center justify-around">
                <div className="flex flex-col items-center">
                  <span className="label-text mb-2">Red</span>
                  <input
                    type="checkbox"
                    className="toggle toggle-primary"
                    checked={ledStatus.red === 1}
                    onChange={(e) => updateLedStatus('red', e.target.checked ? 1 : 0)}
                  />
                </div>
                <div className="flex flex-col items-center">
                  <span className="label-text mb-2">Green</span>
                  <input
                    type="checkbox"
                    className="toggle toggle-primary"
                    checked={ledStatus.green === 1}
                    onChange={(e) => updateLedStatus('green', e.target.checked ? 1 : 0)}
                  />
                </div>
                <div className="flex flex-col items-center">
                  <span className="label-text mb-2">Blue</span>
                  <input
                    type="checkbox"
                    className="toggle toggle-primary"
                    checked={ledStatus.blue === 1}
                    onChange={(e) => updateLedStatus('blue', e.target.checked ? 1 : 0)}
                  />
                </div>
              </div>
            </div>
          </div>
          <div className="card bg-base-100 shadow-md" style={{height: '140px'}}>
            <div className="card-body p-4 flex flex-col justify-between">
              <h2 className="card-title">Control Pump</h2>
              <button
                onClick={togglePump}
                className={`btn ${pumpStatus === 'ON' ? 'btn-danger' : 'btn-success'}`}
              >
                {pumpStatus === 'ON' ? 'Turn Pump Off' : 'Turn Pump On'}
              </button>
            </div>
          </div>
        </div>
      </div>
      <style jsx>{`
        .hover-expand {
          transition: all 0.3s ease;
        }
        .hover-expand:hover {
          transform: translateX(-30px);
        }
        .chart-container {
          width: 350px;
          height: 295px;
        }
      `}</style>
    </div>
  );
}


--- app/components/PlantGrid.tsx ---
// app/components/PlantGrid.tsx

import { useState } from 'react';
import Image from 'next/image';

interface Plant {
  id: number;
  name: string;
  src: string;
}

const plants: Plant[] = [
  { id: 1, name: 'Plant 1', src: '/plant1.svg' },
  { id: 2, name: 'Plant 2', src: '/plant2.svg' },
  { id: 3, name: 'Plant 3', src: '/plant3.svg' }
];

interface PlantGridProps {
  onSelect: (id: number) => void;
}

export default function PlantGrid({ onSelect }: PlantGridProps) {
  return (
    <div className="container mx-auto p-4">
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {plants.map((plant) => (
          <div
            key={plant.id}
            className={`card ${plant.id === 1 ? 'bg-primary text-primary-content' : 'bg-gray-200'}`}
            onClick={() => plant.id === 1 && onSelect(plant.id)}
          >
            <div className="card-body flex flex-col items-center">
              <Image
                src={plant.src}
                alt={plant.name}
                width={100}
                height={100}
                className={plant.id !== 1 ? 'grayscale' : ''}
              />
              <h2 className="card-title">{plant.name}</h2>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}


--- app/components/LineChart.tsx ---
import { Line } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
} from 'chart.js';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

interface LineChartProps {
  data: number[];
  labels: string[];
  events?: string[]; // Array of timestamps where events (e.g., pump activation) occurred
}

const LineChart = ({ data, labels, events }: LineChartProps) => {
  const chartData = {
    labels: labels.map(label => new Date(parseInt(label)).toLocaleTimeString()), // Format timestamps
    datasets: [
      {
        label: 'Value',
        data: data,
        fill: true,
        backgroundColor: 'rgba(75,192,192,0.2)',
        borderColor: 'rgba(75,192,192,1)',
        tension: 0.4,
      },
    ],
  };

  const options = {
    responsive: true,
    maintainAspectRatio: false, // Make the chart fill its container
    plugins: {
      legend: {
        display: false,
      },
      title: {
        display: false,
      },
      tooltip: {
        callbacks: {
          label: function (context: any) {
            const label = context.dataset.label || '';
            const value = context.parsed.y;
            const eventLabel = events?.includes(context.label) ? ' (Pump Activated)' : '';
            return `${label}: ${value}${eventLabel}`;
          },
        },
      },
    },
    scales: {
      x: {
        title: {
          display: true,
          text: 'Time',
        },
      },
      y: {
        title: {
          display: true,
          text: 'Value',
        },
      },
    },
  };

  return (
    <div style={{ position: 'relative', width: '100%', height: '100%' }}>
      <Line data={chartData} options={options} />
    </div>
  );
};

export default LineChart;


--- pages/api/control-led.ts ---
import type { NextApiRequest, NextApiResponse } from 'next';

let ledStatus = {
  red: 0,
  green: 0,
  blue: 0,
};

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'POST') {
    const { red, green, blue } = req.body;
    ledStatus = { red, green, blue };
    return res.status(200).json({ message: 'LED status updated' });
  } else if (req.method === 'GET') {
    return res.status(200).json(ledStatus);
  } else {
    res.setHeader('Allow', ['GET', 'POST']);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


--- pages/api/control-pump.ts ---
import type { NextApiRequest, NextApiResponse } from 'next';

let pumpStatus = 'OFF';

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'POST') {
    const { status } = req.body;
    pumpStatus = status;
    return res.status(200).json({ message: 'Pump status updated' });
  } else if (req.method === 'GET') {
    return res.status(200).json({ pumpStatus });
  } else {
    res.setHeader('Allow', ['GET', 'POST']);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


--- pages/api/sensor-data.ts ---
import type { NextApiRequest, NextApiResponse } from 'next';
import clientPromise from '../../config/db';

interface SensorData {
  temp: number;
  humidity: number;
  light: number;
  soil_moisture: number;
  timestamp: number;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const client = await clientPromise;
  const db = client.db('GrowHouse');

  if (req.method === 'POST') {
    const { temp, humidity, light, soil_moisture } = req.body;
    const timestamp = Date.now();

    await db.collection('sensorData').insertOne({
      temp,
      humidity,
      light,
      soil_moisture,
      timestamp,
    });

    return res.status(200).json({ message: 'Data received' });
  } else if (req.method === 'GET') {
    const sensorData = await db.collection('sensorData').find({}).sort({ timestamp: -1 }).limit(1800).toArray();
    const formattedData = {
      temp: sensorData.map(data => data.temp),
      humidity: sensorData.map(data => data.humidity),
      light: sensorData.map(data => data.light),
      soil_moisture: sensorData.map(data => data.soil_moisture),
      timestamps: sensorData.map(data => data.timestamp.toString()),
      pump_status: 'OFF',  // Default or fetched from another collection if necessary
    };
    return res.status(200).json(formattedData);
  } else {
    res.setHeader('Allow', ['GET', 'POST']);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}


--- pages/api/send-email.ts ---
import { NextApiRequest, NextApiResponse } from 'next';
import nodemailer from 'nodemailer';
import dotenv from 'dotenv';

dotenv.config({ path: '.env.local' });

const transporter = nodemailer.createTransport({
  host: 'mail.smtp2go.com',
  port: 2525, // eller 587
  auth: {
    user: process.env.SMTP2GO_USER,
    pass: process.env.SMTP2GO_PASS,
  },
});

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: `Method ${req.method} not allowed` });
  }

  const { subject, text } = req.body;

  const mailOptions = {
    from: 'ek223yb@student.lnu.se', // Använd den verifierade avsändaradressen
    to: process.env.RECIPIENT_EMAIL,
    subject: subject,
    text: text,
  };

  try {
    const info = await transporter.sendMail(mailOptions);
    console.log('Email sent: ', info.response);
    res.status(200).json({ message: 'Email sent successfully' });
  } catch (error) {
    console.error('Error sending email: ', error);
    res.status(500).json({ error: 'Failed to send email', details: error });
  }
};

export default handler;


--- README-2.md ---

# Building a Smart Grow House Monitor using Raspberry Pi Pico W

**Name:** Efthimis, ek223yb

---

## Project Overview
This project creates a smart grow house monitor using a Raspberry Pi Pico W. It monitors temperature, humidity, light intensity, and soil moisture, automating watering and displaying data on a Next.js dashboard for real-time monitoring. Approximately 5-7 hours to complete.

## Objective

I'm building this device to merge my interests in IoT and agriculture. Forgetfulness in watering plants prompted me to seek a reliable solution. The goal is to automate plant care by monitoring and optimizing environmental conditions, aiming to improve efficiency and growth outcomes.

## Materials

**Materials Specifications and Costs:**
| Item                   | Specifications                      | Cost          | Supplier              |
|------------------------|--------------------------------------|---------------|---------------------|
| Raspberry Pi Pico W    | Microcontroller with WiFi           | 109           | Electrokit     |
| DHT11 Sensor           | Temperature & Humidity Sensor       | 49            | Electrokit     |
| CdS Photoresistor      | Light Intensity Resistor            | 8             | Electrokit     |
| Soil Moisture Sensor   | Soil Moisture Measurement           | 29            | Electrokit     |
| Relay Module           | Controls high power devices         | 42            | Electrokit     |
| RGB LED                | Multi-color LED                     | 20            | Electrokit     |
| Jumper Wires           | Various lengths                     | 29            | Electrokit     |
| Breadboard             | Prototyping board                   | 69            | Electrokit     |
| Battery Holder         | 2x AA cabel connection              | 16            | Electrokit     |
| Water Pump             | 3V Water Pump                       | 45            | Electrokit     |
|              | Total Price                       |       416      |      |


## Computer Setup
**IDE and Tools Used:**
- **Thonny IDE**: For programming the Raspberry Pi Pico W with MicroPython
- **Node.js**: Backend environment for the Next.js application
- **Visual Studio Code**: For developing the Next.js dashboard

**Setup Steps:**
1. **Install Thonny IDE**: Download and install Thonny from [thonny.org](https://thonny.org/).
2. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/).
3. **Clone the Repository**: Clone the project repository to your local machine.
4. **Install Dependencies**: Navigate to the project directory and run `npm install` to install all dependencies.
5. **Flashing the Pico W**:
   - Connect the Pico W to your computer via USB.
   - Open Thonny IDE and select the Pico W as the interpreter.
   - Upload the `Growhouse.py` script to the Pico W.
6. **SMTP2GO setup**:
   - Follow the instructions on their website.
   - Get your email and password for the .env.local file.
7. **MongoDB setup**
   - Follow the instructions on their website.
   - Get your MONGODB_URI for the .env.local file.
8. **Update .env.local**
   - Fill out the information from steps 6-7.
   - Put the email you'd like to recive the notifications on RECIPIENT_EMAIL.


## Putting Everything Together
**Circuit Diagram:**
- Connect the DHT11 sensor to GPIO15.
- Connect the light sensor to ADC pin 27.
- Connect the soil moisture sensor to ADC pin 26.
- Connect the relay module to GPIO2.
- Connect the RGB LED to GPIO17 (red), GPIO18 (green), and GPIO19 (blue).

![picture of circuit diagram here](#)

**Electrical Calculations:**
- Ensure the total current does not exceed the Pico W's capacity.
- Use appropriate resistors for the LEDs to prevent damage.

## Platform
**Platform Choice:**
- **Next.js**: Chosen for its ease of use in building responsive web applications and its excellent support for TypeScript and React.
- **Local Hosting**: The dashboard is hosted locally for this project, but it can be scaled to a cloud-based solution in the future.
- **Database**: Data is stored in a MongoDB instance, which allows for efficient querying and storage of time-series data.

### Transmitting the Data / Connectivity

**How is the data transmitted to the internet or local server?**

Data is transmitted from the Raspberry Pi Pico W to a local server using WiFi and HTTP POST requests. The process involves the following steps:

1. **Data Collection**: The Raspberry Pi Pico W gathers sensor readings (temperature, humidity, light intensity, and soil moisture).
2. **WiFi Connection**: The device connects to the local WiFi network.
3. **HTTP POST Request**: Sensor data is formatted into a JSON object and sent to the Next.js server using an HTTP POST request.
4. **Server Processing**: The Next.js server receives the data, processes it, and stores it in a MongoDB database.

**How often is the data sent?**

Data is sent every 60 seconds to balance the need for real-time monitoring with power consumption.

**Protocols Used:**

- **WiFi**: For connecting the Raspberry Pi Pico W to the local network.
  - **Advantages**: Reliable and widely available.
  - **Considerations**: Power consumption is higher, but manageable with a stable power source.
- **HTTP**: For transmitting sensor data to the Next.js server.
  - **Advantages**: Simple to implement and integrates well with web applications.
  - **Considerations**: Slightly less efficient than other protocols like MQTT, but suitable for the project's data transmission frequency.


## Presenting the Data
The dashboard is built using React and displays real-time data from the sensors. Data is preserved in a MongoDB database and fetched every 2 seconds for the dashboard.

![Dashboard](/public/dashboard.png)

**Database Choice:**
- **MongoDB**: Chosen for its scalability and efficiency in handling large volumes of time-series data.

## Finalizing the Design
The final project successfully monitors and controls the grow house environment, providing valuable data and automation. Future improvements could include calculating and implementing a cloud-based dashboard for remote monitoring. Additionally, enhancements could be made in calculating the power requirements to ensure the system operates independently without being connected to a computer. It would also be beneficial to configure how frequently the system reads data, saves data to the database, and other related parameters to optimize performance and resource utilization.

![pictures and video presentation of the final project here](#)

## Conclusion
This project demonstrates the potential of IoT in smart agriculture, providing a cost-effective solution for monitoring and managing plant growth environments. The insights gained can help in optimizing growth conditions and improving yields.

---


--- project_structure.txt ---
.
├── README.md
├── app
│   ├── components
│   │   ├── Footer.tsx
│   │   ├── Navbar.tsx
│   │   ├── LineChart.tsx
│   │   ├── PlantDetails.tsx
│   │   └── PlantGrid.tsx
│   ├── globals.css
│   ├── layout.tsx
│   └── page.tsx
├── next-env.d.ts
├── next.config.mjs
├── package-lock.json
├── package.json
├── pages
│   └── api
│       ├── control-led.ts
│       ├── control-pump.ts
│       ├── send-email.ts
│       └── sensor-data.ts
├── postcss.config.mjs
├── project_structure.txt
├── public
│   ├── greenhouse-icon.svg
│   ├── plant1.svg
│   ├── plant2.svg
│   ├── plant3.svg
│   └── watering-can-icon.svg
├── tailwind.config.ts
└── tsconfig.json



